/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * AssetMeterJFrame.java
 *
 * Created on Feb 25, 2009, 8:54:07 PM
 */

package org.jdesktop.wonderland.modules.assetmeter.client;

import java.awt.Component;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import javax.swing.AbstractListModel;
import javax.swing.BorderFactory;
import javax.swing.BoxLayout;
import javax.swing.JLabel;
import javax.swing.JList;
import javax.swing.JPanel;
import javax.swing.JProgressBar;
import javax.swing.ListCellRenderer;
import javax.swing.SwingUtilities;
import javax.swing.Timer;
import org.jdesktop.wonderland.client.assetmgr.Asset;
import org.jdesktop.wonderland.client.assetmgr.AssetManager;
import org.jdesktop.wonderland.client.assetmgr.AssetManager.AssetProgressListener;

/**
 * A visual "meter" for asset loading progress. Registers for events with the
 * Asset Manager. Keeps the asset meters in a scrolling list.
 *
 * @author Jordan Slott <jslott@dev.java.net>
 */
public class AssetMeterJFrame extends javax.swing.JFrame {

    /* An synchronized ordered map of Assets to their downloading status objects */
    private Map<String, DownloadingAsset> downloadingAssetMap;

    /* The default list model */
    private AssetIndicatorListModel listModel = new AssetIndicatorListModel();

    /* The progress listener */
    private MeterProgressListener progressListener;

    /** Creates new form AssetMeterJFrame */
    public AssetMeterJFrame() {
        initComponents();
        downloadingAssetMap = Collections.synchronizedMap(new LinkedHashMap());

        // Have the JList renderer the asset indicators
        loadingAssetList.setModel(listModel);
        loadingAssetList.setCellRenderer(new AssetIndicatorCellRenderer());
        
        // Add a listener to the asset manager
        progressListener = new MeterProgressListener();
        AssetManager manager = AssetManager.getAssetManager();
        manager.addProgressListener(progressListener);
    }

    /**
     * Stop listener for events
     */
    public void deactivate() {
        AssetManager manager = AssetManager.getAssetManager();
        manager.removeProgressListener(progressListener);
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        loadingAssetPanel = new javax.swing.JPanel();
        loadingAssetList = new javax.swing.JList();

        setTitle("Asset Meter");
        getContentPane().setLayout(new java.awt.GridLayout(1, 0));

        loadingAssetPanel.setLayout(new java.awt.GridLayout(1, 0));

        loadingAssetList.setBackground(new java.awt.Color(204, 204, 204));
        loadingAssetList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        loadingAssetList.setVisibleRowCount(10);
        loadingAssetPanel.add(loadingAssetList);

        getContentPane().add(loadingAssetPanel);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Updates the given downloading asset
     */
    private void updateDownloadingAsset(Asset asset, final int readBytes, final int percent) {
        // Update the values in the downloading asset indicator using a swing
        // worker for thread safeness.
        final Asset[] assetArray = new Asset[] { asset };
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                DownloadingAsset da = downloadingAssetMap.get(assetArray[0].getAssetURI().toExternalForm());
                if (da != null) {
                    da.readBytes = readBytes;
                    da.percentage = percent;
                    da.indicator.setAssetProgressValue(da.percentage);
                    listModel.updateElement(da.indicator);
                }
            }
        });
    }

    /**
     * Adds a new asset to the list. This updates the UI as necessary
     */
    private void addDownloadingAsset(Asset asset) {
        // Adds a downloading asset to the list using a swing worker for thread
        // safeness
        DownloadingAsset da = new DownloadingAsset();
        da.asset = asset;
        da.readBytes = 0;
        da.percentage = 0;
        da.indicator.setAssetProgressValue(0);
        da.indicator.setAssetLabel(asset.getAssetURI().toExternalForm());
        downloadingAssetMap.put(asset.getAssetURI().toExternalForm(), da);

        final AssetIndicator aiArray[] = new AssetIndicator[]{da.indicator};
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                listModel.addElementToTail(aiArray[0]);
            }
        });
    }

    /**
     * Removes a downloading asset from the list and updates the UI as necessary.
     */
    private void removeDownloadingAsset(Asset asset) {
        // Removes a downloading asset from the list using a swing worker for
        // thread safeness
        DownloadingAsset da = downloadingAssetMap.get(asset.getAssetURI().toExternalForm());
        downloadingAssetMap.remove(asset.getAssetURI().toExternalForm());

        final AssetIndicator aiArray[] = new AssetIndicator[] { da.indicator };
        new Timer(750, new ActionListener() {
            public void actionPerformed(ActionEvent e) {
                listModel.removeElement(aiArray[0]);
                ((Timer) e.getSource()).stop();
            }
        }).start();
    }

    /**
     * A class that represents an asset currently being downloaded and its
     * status
     */
    class DownloadingAsset {
        public Asset asset = null;
        public int readBytes = 0;
        public int percentage = -1;
        private AssetIndicator indicator = new AssetIndicator();
    }

    /**
     * A progress listener for assets being downloaded by the Asset Manager
     */
    class MeterProgressListener implements AssetProgressListener {
        public void downloadProgress(Asset asset, int readBytes, int percentage) {
            // Check to see if the asset is already in the list, otherwise
            // add it. We need to synchronized according to the asset to make
            // sure we do not add it twice
            synchronized (this) {
                if (downloadingAssetMap.containsKey(asset.getAssetURI().toExternalForm()) == false) {
                    addDownloadingAsset(asset);
                }
                else {
                    updateDownloadingAsset(asset, readBytes, percentage);
                }
            }
        }

        public void downloadFailed(Asset asset) {
            // Simply try to remove the asset from the list, synchronized
            // on the asset
            synchronized (this) {
                removeDownloadingAsset(asset);
            }
        }

        public void downloadCompleted(Asset asset) {
            // Simply try to remove the asset from the list, synchrnoized
            // on the asset
            synchronized (this) {
                removeDownloadingAsset(asset);
            }
        }
    }

    /**
     * The list model to hold all of the asset indicators
     */
    class AssetIndicatorListModel extends AbstractListModel {

        /* An ordered list of downloading indicators */
        private List<AssetIndicator> indicatorList = new LinkedList();

        public int getSize() {
            return indicatorList.size();
        }

        public Object getElementAt(int index) {
            return indicatorList.get(index);
        }

        public synchronized void addElementToTail(AssetIndicator ai) {
            indicatorList.add(ai);
            fireIntervalAdded(ai, indicatorList.size() - 1, indicatorList.size() - 1);
        }

        public synchronized void removeElement(AssetIndicator ai) {
            int index = indicatorList.indexOf(ai);
            if (index != -1) {
                indicatorList.remove(index);
                fireIntervalRemoved(this, index, index);
            }
        }

        public synchronized void updateElement(AssetIndicator ai) {
            int index = indicatorList.indexOf(ai);
            if (index != -1) {
                fireContentsChanged(this, index, index);
            }
        }
    }

    /**
     * A list cell rendered for the Asset Indicator
     */
    class AssetIndicatorCellRenderer implements ListCellRenderer {
        public Component getListCellRendererComponent(JList list, Object value, int index, boolean isSelected, boolean cellHasFocus) {
            return ((AssetIndicator)value);
        }
    }

    /**
     * A JPanel that holds a label and a progress bar.
     */
    class AssetIndicator extends JPanel {
        private JProgressBar progressBar;
        private JLabel assetLabel;

        /**
         * Constructor, assembles the components of the panel
         */
        public AssetIndicator() {
            super();

            // Make the layout a vertical box layout
            setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));
            setBorder(BorderFactory.createEmptyBorder(4, 10, 2, 10));
            setAlignmentX(0.0f);
            setAlignmentY(0.0f);

            // Create the label, make the font a bit smaller and add it to
            // the panel
            assetLabel = new JLabel("");
            assetLabel.setAlignmentX(0.0f);
            assetLabel.setAlignmentY(0.0f);
            Font font = assetLabel.getFont();
            assetLabel.setFont(font.deriveFont(Font.PLAIN, 11));
//            assetLabel.setPreferredSize(getSize());
            add(assetLabel);

            // Create the progress bar and add it to the panel. Make sure it
            // is always of a maximum height
            progressBar = new JProgressBar();
//            progressBar.addComponentListener(new ComponentAdapter() {
//                @Override
//                public void componentResized(ComponentEvent e) {
//                    Dimension size = progressBar.getSize();
//                    size.setSize(size.getWidth(), 15);
//                    progressBar.setSize(size);
//                }
//
//            });
            progressBar.setAlignmentX(0.0f);
            progressBar.setAlignmentY(0.0f);
            progressBar.setValue(0);
//            progressBar.setPreferredSize(getSize());
            add(progressBar);
        }

        /**
         * Sets the value of the asset label.
         */
        public void setAssetLabel(String label) {
            assetLabel.setText(label);
        }

        /**
         * Sets the value of the progress bar.
         */
        public void setAssetProgressValue(int value) {
            progressBar.setValue(value);
        }

        /**
         * Increments the value of the progress bar by one
         */
        public void incrementAssetProgressValue() {
            progressBar.setValue(progressBar.getValue() + 1);
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JList loadingAssetList;
    private javax.swing.JPanel loadingAssetPanel;
    // End of variables declaration//GEN-END:variables
}
