/**
 * Project Wonderland
 *
 * Copyright (c) 2004-2008, Sun Microsystems, Inc., All Rights Reserved
 *
 * Redistributions in source code form must reproduce the above
 * copyright and this condition.
 *
 * The contents of this file are subject to the GNU General Public
 * License, Version 2 (the "License"); you may not use this file
 * except in compliance with the License. A copy of the License is
 * available at http://www.opensource.org/licenses/gpl-license.php.
 *
 * $Revision$
 * $Date$
 * $State$
 */
package org.jdesktop.wonderland.client.input;

import java.awt.Canvas;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.event.MouseWheelListener;
import java.awt.event.KeyListener;
import java.util.concurrent.LinkedBlockingQueue;

/**
 * A singleton container for all of the processor objects in the Wonderland input subsystem.
 *
 * The InputManager provides a global EventMode which which can take on one of two values: WORLD and APP. 
 * When the EventMode is WORLD it is okay for event listeners which modify the world to handle events and
 * app-related event listeners should ignore incoming events. When the EventMode is APP, it is okay for app-related
 * event listeners to handle events and world-related event listeners must ignore incoming events.
 *
 * The InputManager supports event listener (EventListener) objects. These listeners can be added to entities
 * in the world in order to allow these entities to respond to events. These events can be generated as a result
 * of user input or can be programmatically generated by other parts of the client.
 *
 * The InputManager also supports a set of global event listeners. These are independent of 
 * any entities. The system always delivers all events to global event listeners which are willing 
 * to consume these events. Note: the return values of propagateToParent() and propagateToUnder() for global listeners
 * are ignored. Note: pickData is null for events received by the global listeners.
 *
 * @author deronj
 */

// TODO: generate 3D enter/exit events for canvas enter exit

@InternalAPI
public abstract class InputManager 
    implements MouseListener, MouseMotionListener, MouseWheelListener, KeyListener
{
    /* TODO: the non-embedded swing case is for prototyping only. Eventually this should be true */
    private static ENABLE_EMBEDDED_SWING = false;

    /** The singleton input manager */
    private static InputManager inputManager;

    /** The singleton entity resolver. (Used only in non-embedded swing case). */
    protected EntityResolver entityResolver;

    /** The singleton event distributor. */
    protected EventDistributor eventDistributor;

    /** The global event mode type. */
    public static enum EventMode { WORLD, APP };

    /**
     * Returns the input manager singleton. You must initialize the input manager 
     * in order to start it processing input events.
     */
    public static InputManager getInputManager () {
	if (inputManager == null) {
	    inputManager = new InputManager();
	}
	return inputManager;
    }
    
    /**
     * Returns the current event mode. By default, event mode is WORLD.
     * @return The current event mode.
     */
    public static EventMode getEventMode () {
	if (eventDistributor == null) {
	    initializeEventDistributor();
	}
	return eventDistributor.getEventMode();
    }


    /**
     * Returns true if the event mode is currently WORLD.
     */
    public static isWorldMode () {
	return getEventMode() == EventMode.WORLD;
    }

    /**
     * Returns true if the event mode is currently APP.
     */
    public static isAppMode () {
	return getEventMode() == EventMode.APP;
    }

    /**
     * Sets the event mode.
     * @param The new event mode.
     */
    public static void setEventMode (EventMode eventMode) {
	if (eventDistributor == null) {
	    eventDistributor = EventDistributor.getEventDistributor();
	}
	eventDistributor.setEventMode(eventMode);
    }

    
    /** 
     *
     * Initialize the input manager to receive input events from the given AWT canvas
     * and start the input manager running.
     *
     * @param canvas The AWT canvas which generates AWT user events.
     */
    public void initialize (Canvas canvas) {
	this.canvas = canvas;

	// Initialize the input system subcomponents
	initalizeEntityResolver();
	if (eventDistributor == null) {
	    initializeEventDistributor();
	}

	canvas.addKeyListener(this);

	if (!ENABLE_EMBEDDED_SWING) {
	    // When not using Embedded Swing the input manager receives events directly from the AWT canvas.
	    canvas.addMouseListener(this);
	    canvas.addMouseMotionListener(this);
	    canvas.addMouseWheelListener(this);
	}
    }

    /**
     * <@inheritDoc>
     * Only used in the non-embedded swing case.
     */
    @InternalAPI
    public void mouseClicked(MouseEvent e) {
	entityResolver.resolveMouseEventNonSwing(e);
    }
    
    /**
     * <@inheritDoc>
     * Only used in the non-embedded swing case.
     */
    @InternalAPI
    public void mouseEntered(MouseEvent e) {
	entityResolver.resolveMouseEventNonSwing(e);
    }

    /**
     * <@inheritDoc>
     * Only used in the non-embedded swing case.
     */
    @InternalAPI
    public void mouseExited(MouseEvent e) {
	entityResolver.resolveMouseEventNonSwing(e);
    }

    /**
     * <@inheritDoc>
     * Only used in the non-embedded swing case.
     */
    @InternalAPI
    public void mousePressed(MouseEvent e) {
	entityResolver.resolveMouseEventNonSwing(e);
    }

    /**
     * <@inheritDoc>
     * Only used in the non-embedded swing case.
     */
    @InternalAPI
    public void mouseReleased(MouseEvent e) {
	entityResolver.resolveMouseEventNonSwing(e);
    }

    /**
     * <@inheritDoc>
     * Only used in the non-embedded swing case.
     */
    @InternalAPI
    public void mouseDragged(MouseEvent e) {
	entityResolver.resolveMouseEventNonSwing(e);
    }

    /**
     * <@inheritDoc>
     * Only used in the non-embedded swing case.
     */
    @InternalAPI
    public void mouseMoved(MouseEvent e) {
	entityResolver.resolveMouseEventNonSwing(e);
    }
    
    /**
     * <@inheritDoc>
     * Only used in the non-embedded swing case.
     */
    @InternalAPI
    public void mouseWheelMoved(MouseWheelEvent e) {
	entityResolver.resolveMouseEventNonSwing(e);
    }
    
    /**
     * <@inheritDoc>
     */
    @InternalAPI
    public void keyPressed(KeyEvent e) {
	if (ENABLE_EMBEDDED_SWING) {
	    entityResolver.resolveKeyEventSwing(e);
	} else {
	    entityResolver.resolveKeyEventNonSwing(e);
	}
    }

    /**
     * <@inheritDoc>
     */
    @InternalAPI
    public void keyReleased(KeyEvent e) {
	if (ENABLE_EMBEDDED_SWING) {
	    entityResolver.resolveKeyEventSwing(e);
	} else {
	    entityResolver.resolveKeyEventNonSwing(e);
	}
    }

    /**
     * <@inheritDoc>
     */
    @InternalAPI
    public void keyTyped(KeyEvent e) {
	if (ENABLE_EMBEDDED_SWING) {
	    entityResolver.resolveKeyEventSwing(e);
	} else {
	    entityResolver.resolveKeyEventNonSwing(e);
	}
    }

    /**
     * Subclass-specific initialization of the entity resolver component.
     */
    protected abstract void initializeEntityResolver ();

    /**
     * Subclass-specific initialization of the event distributor component.
     */
    protected abstract void initializeEventDistributor ();

    /**
     * Add an event listener to be tried once per event. This global listener can be added only once.
     * Subsequent attempts to add it will be ignored.
     *
     * Note: It is not a good idea to call this from inside EventListener.computeEvent function.
     * However, it is okay to call this from inside EventListener.commitEvent function if necessary.
     *
     * @param Listener The global event listener to be added.
     */
    public void addGlobalEventListener (EventListener listener) {
	if (eventDistributor == null) {
	    initializeEventDistributor();
	}
	return eventDistributor.addGlobalEventListener(listener);
	
    }

    /**
     * Remove this global event listener.
     *
     * Note: It is not a good idea to call this from inside EventListener.computeEvent function.
     * However, it is okay to call this from inside EventListener.commitEvent function if necessary.
     *
     * @param The entity to which to attach this event listener.
     */
    public void removeGlobalEventListener (EventListener listener) {
	if (eventDistributor == null) return;
	eventDistributor.removeGlobalListener(listener);
    }
}
