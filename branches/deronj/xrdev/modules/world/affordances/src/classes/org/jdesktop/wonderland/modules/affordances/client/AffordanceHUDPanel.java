/**
 * Project Wonderland
 *
 * Copyright (c) 2004-2009, Sun Microsystems, Inc., All Rights Reserved
 *
 * Redistributions in source code form must reproduce the above
 * copyright and this condition.
 *
 * The contents of this file are subject to the GNU General Public
 * License, Version 2 (the "License"); you may not use this file
 * except in compliance with the License. A copy of the License is
 * available at http://www.opensource.org/licenses/gpl-license.php.
 *
 * Sun designates this particular file as subject to the "Classpath"
 * exception as provided by Sun in the License file that accompanied
 * this code.
 */
package org.jdesktop.wonderland.modules.affordances.client;

import java.util.Hashtable;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JComponent;
import javax.swing.JFrame;
import javax.swing.JLabel;
import org.jdesktop.mtgame.Entity;
import org.jdesktop.wonderland.client.cell.Cell;
import org.jdesktop.wonderland.client.cell.CellComponent;
import org.jdesktop.wonderland.client.input.Event;
import org.jdesktop.wonderland.client.input.EventClassListener;
import org.jdesktop.wonderland.client.input.InputManager;
import org.jdesktop.wonderland.client.scenemanager.SceneManager;
import org.jdesktop.wonderland.client.scenemanager.event.SelectionEvent;
import org.jdesktop.wonderland.modules.affordances.client.cell.AffordanceCellComponent;
import org.jdesktop.wonderland.modules.affordances.client.cell.AffordanceException;
import org.jdesktop.wonderland.modules.affordances.client.cell.ResizeAffordanceCellComponent;
import org.jdesktop.wonderland.modules.affordances.client.cell.RotateAffordanceCellComponent;
import org.jdesktop.wonderland.modules.affordances.client.cell.TranslateAffordanceCellComponent;

/**
 * A panel to display affordance items on the HUD.
 * 
 * @author Jordan Slott <jslott@dev.java.net>
 */
public class AffordanceHUDPanel extends javax.swing.JPanel {

    private JFrame frame = null;

    /** Creates new form AffordanceHUDPanel */
    public AffordanceHUDPanel(JFrame frame) {
        initComponents();

        // Paint the labels on the ticks properly from 1.0 to 5.0
        Hashtable<Integer, JComponent> labels = new Hashtable();
        labels.put(0, new JLabel("1.0"));
        labels.put(100, new JLabel("2.0"));
        labels.put(200, new JLabel("3.0"));
        labels.put(300, new JLabel("4.0"));
        labels.put(400, new JLabel("5.0"));
        sizeSlider.setLabelTable(labels);
        this.frame = frame;
        
        // Listen for selections to update the HUD panel
        InputManager.inputManager().addGlobalEventListener(new SelectionListener());
    }

    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        translateToggleButton = new javax.swing.JToggleButton();
        rotateToggleButton = new javax.swing.JToggleButton();
        resizeToggleButton = new javax.swing.JToggleButton();
        slidePanel = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jPanel1 = new javax.swing.JPanel();
        jLabel3 = new javax.swing.JLabel();
        sizeSlider = new javax.swing.JSlider();
        jLabel4 = new javax.swing.JLabel();

        setBorder(javax.swing.BorderFactory.createEmptyBorder(2, 2, 2, 2));
        setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.LEFT, 10, 0));

        translateToggleButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/org/jdesktop/wonderland/modules/affordances/client/resources/translate_icon.png"))); // NOI18N
        translateToggleButton.setBorderPainted(false);
        translateToggleButton.setIconTextGap(0);
        translateToggleButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
        translateToggleButton.setMaximumSize(new java.awt.Dimension(43, 43));
        translateToggleButton.setMinimumSize(new java.awt.Dimension(43, 43));
        translateToggleButton.setPreferredSize(new java.awt.Dimension(43, 43));
        translateToggleButton.setSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/org/jdesktop/wonderland/modules/affordances/client/resources/translate_icon_selected.png"))); // NOI18N
        translateToggleButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                translateToggleButtonActionPerformed(evt);
            }
        });
        add(translateToggleButton);

        rotateToggleButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/org/jdesktop/wonderland/modules/affordances/client/resources/rotate_icon.png"))); // NOI18N
        rotateToggleButton.setBorderPainted(false);
        rotateToggleButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
        rotateToggleButton.setMaximumSize(new java.awt.Dimension(43, 43));
        rotateToggleButton.setMinimumSize(new java.awt.Dimension(43, 43));
        rotateToggleButton.setPreferredSize(new java.awt.Dimension(43, 43));
        rotateToggleButton.setSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/org/jdesktop/wonderland/modules/affordances/client/resources/rotate_icon_selected.png"))); // NOI18N
        rotateToggleButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rotateToggleButtonActionPerformed(evt);
            }
        });
        add(rotateToggleButton);

        resizeToggleButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/org/jdesktop/wonderland/modules/affordances/client/resources/scale_icon.png"))); // NOI18N
        resizeToggleButton.setBorderPainted(false);
        resizeToggleButton.setMargin(new java.awt.Insets(0, 0, 0, 0));
        resizeToggleButton.setMaximumSize(new java.awt.Dimension(43, 43));
        resizeToggleButton.setMinimumSize(new java.awt.Dimension(43, 43));
        resizeToggleButton.setPreferredSize(new java.awt.Dimension(43, 43));
        resizeToggleButton.setSelectedIcon(new javax.swing.ImageIcon(getClass().getResource("/org/jdesktop/wonderland/modules/affordances/client/resources/scale_icon_selected.png"))); // NOI18N
        resizeToggleButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                resizeToggleButtonActionPerformed(evt);
            }
        });
        add(resizeToggleButton);

        slidePanel.setLayout(new javax.swing.BoxLayout(slidePanel, javax.swing.BoxLayout.Y_AXIS));

        jLabel1.setFont(new java.awt.Font("Lucida Grande", 0, 12));
        jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        jLabel1.setText("Affordance Size");
        jLabel1.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        slidePanel.add(jLabel1);

        jPanel1.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.CENTER, 0, 0));

        jLabel3.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        jLabel3.setText("1x");
        jLabel3.setIconTextGap(0);
        jPanel1.add(jLabel3);

        sizeSlider.setMajorTickSpacing(100);
        sizeSlider.setMaximum(400);
        sizeSlider.setPaintTicks(true);
        sizeSlider.addChangeListener(new javax.swing.event.ChangeListener() {
            public void stateChanged(javax.swing.event.ChangeEvent evt) {
                sizeSliderStateChanged(evt);
            }
        });
        jPanel1.add(sizeSlider);

        jLabel4.setText("5x");
        jPanel1.add(jLabel4);

        slidePanel.add(jPanel1);

        add(slidePanel);
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Updates the GUI items in this panel for the currently selected cell. If
     * there is nothing selected, do nothing
     */
    public void updateGUI() {
        // Fetch the currently selected Cell. If none, then do nothing
        Cell cell = getSelectedCell();
        if (cell == null) {
            frame.setTitle("Edit Cell: <none selected>");
            translateToggleButton.setSelected(false);
            translateToggleButton.setEnabled(false);
            rotateToggleButton.setSelected(false);
            rotateToggleButton.setEnabled(false);
            resizeToggleButton.setSelected(false);
            resizeToggleButton.setEnabled(false);
            sizeSlider.setValue(50);
            sizeSlider.setEnabled(false);
            return;
        }

        // Set the name of the Cell label
        frame.setTitle("Edit Cell: " + cell.getName());
        translateToggleButton.setEnabled(true);
        rotateToggleButton.setEnabled(true);
        resizeToggleButton.setEnabled(true);
        sizeSlider.setEnabled(true);

        // See if there is a translate component on the Cell. If so, then set
        // the toggle button state.
        CellComponent component = cell.getComponent(TranslateAffordanceCellComponent.class);
        translateToggleButton.setSelected(component != null);

        // In theory each affordance component can hold a different size value.
        // In practice this can never happen since the GUI enforces all of the
        // affordances to have the same size. So we just use the size from the
        // translate affordance to initialize the slider value
        if (component != null) {
            float size = ((AffordanceCellComponent) component).getSize();
            sizeSlider.setValue((int) ((size - 1.0f) * 100.0f));
        }
        else {
            sizeSlider.setValue(50);
        }

        // See if there is a rotate component on the Cell. If so, then set the
        // toggle button state.
        component = cell.getComponent(RotateAffordanceCellComponent.class);
        rotateToggleButton.setSelected(component != null);

        // See if there is a resize component on the Cell. If so, then set the
        // toggle button state.
        component = cell.getComponent(ResizeAffordanceCellComponent.class);
        resizeToggleButton.setSelected(component != null);
    }

    private void translateToggleButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_translateToggleButtonActionPerformed
        setTranslationVisible(translateToggleButton.isSelected());
    }//GEN-LAST:event_translateToggleButtonActionPerformed

    private void rotateToggleButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rotateToggleButtonActionPerformed
        setRotationVisible(rotateToggleButton.isSelected());
    }//GEN-LAST:event_rotateToggleButtonActionPerformed

    private void resizeToggleButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_resizeToggleButtonActionPerformed
        setResizingVisible(resizeToggleButton.isSelected());
    }//GEN-LAST:event_resizeToggleButtonActionPerformed

    private void sizeSliderStateChanged(javax.swing.event.ChangeEvent evt) {//GEN-FIRST:event_sizeSliderStateChanged
        updateAffordanceSize();
}//GEN-LAST:event_sizeSliderStateChanged

    /**
     * Manually set whether the translation affordance is visible (true) or
     * not (false).
     *
     * @param visible True if the translation affordance should be visible
     */
    public void setTranslationVisible(boolean visible) {
        // Fetch the currently selected Cell. If none, then do nothing
        Cell cell = getSelectedCell();
        if (cell == null) {
            return;
        }

        // Make sure the translate toggle button is in the same state. We need
        // to check to make sure the toggle button isn't already in this
        // state to prevent generated a spurious event.
        if (translateToggleButton.isSelected() != visible) {
            translateToggleButton.setSelected(visible);
        }

        // See if there is already a translate component on the Cell.
        CellComponent component = cell.getComponent(TranslateAffordanceCellComponent.class);
        
        // If we are selecting the translate toggle button, then add the translate
        // component if it is not already on there. Also, set its size.
        if (visible == true) {
            if (component == null) {
                try {
                    component = new TranslateAffordanceCellComponent(cell);
                } catch (AffordanceException ex) {
                    Logger.getLogger(AffordanceHUDPanel.class.getName()).log(Level.SEVERE, null, ex);
                }
                cell.addComponent(component);
            }
            ((AffordanceCellComponent)component).setSize(getSliderSize());
        }
        else {
            // Otherwise if the remove exists, then remove it from the Cell
            if (component != null) {
                ((AffordanceCellComponent)component).remove();
            }
        }
    }

    /**
     * Manually set whether the rotation affordance is visible (true) or
     * not (false).
     *
     * @param visible True if the rotation affordance should be visible
     */
    public void setRotationVisible(boolean visible) {
        // Fetch the currently selected Cell. If none, then do nothing
        Cell cell = getSelectedCell();
        if (cell == null) {
            return;
        }

        // Make sure the rotation toggle button is in the same state. We need
        // to check to make sure the toggle button isn't already in this
        // state to prevent generated a spurious event.
        if (rotateToggleButton.isSelected() != visible) {
            rotateToggleButton.setSelected(visible);
        }

        // See if there is already a rotate component on the Cell.
        CellComponent component = cell.getComponent(RotateAffordanceCellComponent.class);

        // If we are selecting the rotation toggle button, then add the rotate
        // component if it is not already on there. Also, set its size.
        if (visible == true) {
            if (component == null) {
                try {
                    component = new RotateAffordanceCellComponent(cell);
                } catch (AffordanceException ex) {
                    Logger.getLogger(AffordanceHUDPanel.class.getName()).log(Level.SEVERE, null, ex);
                }
                cell.addComponent(component);
            }
            ((AffordanceCellComponent)component).setSize(getSliderSize());
        }
        else {
            // Otherwise if the remove exists, then remove it from the Cell
            if (component != null) {
                ((AffordanceCellComponent)component).remove();
            }
        }
    }

    /**
     * Manually set whether the resizing affordance is visible (true) or
     * not (false).
     *
     * @param visible True if the resizing affordance should be visible
     */
    public void setResizingVisible(boolean visible) {
        // Fetch the currently selected Cell. If none, then do nothing
        Cell cell = getSelectedCell();
        if (cell == null) {
            return;
        }

        // Make sure the resize toggle button is in the same state. We need
        // to check to make sure the toggle button isn't already in this
        // state to prevent generated a spurious event.
        if (resizeToggleButton.isSelected() != visible) {
            resizeToggleButton.setSelected(visible);
        }

        // See if there is already a rotate component on the Cell.
        CellComponent component = cell.getComponent(ResizeAffordanceCellComponent.class);

        // If we are selecting the resize toggle button, then add the resize
        // component if it is not already on there. Also, set its size.
        if (visible == true) {
            if (component == null) {
                try {
                    component = new ResizeAffordanceCellComponent(cell);
                } catch (AffordanceException ex) {
                    Logger.getLogger(AffordanceHUDPanel.class.getName()).log(Level.SEVERE, null, ex);
                }
                cell.addComponent(component);
            }
            ((AffordanceCellComponent)component).setSize(getSliderSize());
        }
        else {
            // Otherwise if the remove exists, then remove it from the Cell
            if (component != null) {
                ((AffordanceCellComponent)component).remove();
            }
        }
    }

    /**
     * Returns the currently selected cell, null if no cell is currently
     * selected.
     */
    private Cell getSelectedCell() {
        SceneManager manager = SceneManager.getSceneManager();
        List<Entity> entityList = manager.getSelectedEntities();
        if (entityList != null && entityList.size() > 0) {
            return SceneManager.getCellForEntity(entityList.get(0));
        }
        return null;
    }

    /**
     * Returns the value of the size, as a floating point between 1.0 and 5.0
     */
    private float getSliderSize() {
        return ((float) sizeSlider.getValue() / 100.0f) + 1.0f;
    }

    /**
     * Updates the size of the affordances using the current value of the size
     * slider
     */
    private void updateAffordanceSize() {
        // Fetch the current value of the slide and the currently selected
        // cell
        float newSize = getSliderSize();
        Cell cell = getSelectedCell();
        if (cell == null) {
            return;
        }

        // Set the size on the translate affordance
        TranslateAffordanceCellComponent translateComponent = cell.getComponent(TranslateAffordanceCellComponent.class);
        if (translateComponent != null) {
            translateComponent.setSize(newSize);
        }

        // Set the size on the rotate affordance
        RotateAffordanceCellComponent rotateComponent = cell.getComponent(RotateAffordanceCellComponent.class);
        if (rotateComponent != null) {
            rotateComponent.setSize(newSize);
        }

        // Set the size on the resize affordance
        ResizeAffordanceCellComponent resizeComponent = cell.getComponent(ResizeAffordanceCellComponent.class);
        if (resizeComponent != null) {
            resizeComponent.setSize(newSize);
        }
    }

    /**
     * Inner class that listens for changes to the selection and upates the
     * state of the dialog appropriately
     */
    class SelectionListener extends EventClassListener {

        @Override
        public Class[] eventClassesToConsume() {
            return new Class[] { SelectionEvent.class };
        }

        @Override
        public void commitEvent(Event event) {
            // Update the GUI based upon the newly selected Entity and Cell
            updateGUI();
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JToggleButton resizeToggleButton;
    private javax.swing.JToggleButton rotateToggleButton;
    private javax.swing.JSlider sizeSlider;
    private javax.swing.JPanel slidePanel;
    private javax.swing.JToggleButton translateToggleButton;
    // End of variables declaration//GEN-END:variables
}
