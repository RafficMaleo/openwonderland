/*
 * CellBoundsViewer.java
 *
 * Created on January 29, 2008, 9:36 AM
 */

package org.jdesktop.wonderland.client.tools;

import com.jme.bounding.BoundingBox;
import com.jme.bounding.BoundingSphere;
import com.jme.bounding.BoundingVolume;
import com.jme.math.Vector3f;
import java.awt.BorderLayout;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseMotionAdapter;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import java.lang.reflect.Constructor;
import java.util.HashMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JPanel;
import org.jdesktop.wonderland.client.ClientContext;
import org.jdesktop.wonderland.client.avatar.LocalAvatar;
import org.jdesktop.wonderland.client.cell.Cell;
import org.jdesktop.wonderland.client.cell.CellCache;
import org.jdesktop.wonderland.client.cell.CellCacheBasicImpl;
import org.jdesktop.wonderland.client.cell.CellCacheClient;
import org.jdesktop.wonderland.client.cell.EntityCell;
import org.jdesktop.wonderland.client.comms.LoginFailureException;
import org.jdesktop.wonderland.client.comms.LoginParameters;
import org.jdesktop.wonderland.client.comms.WonderlandServerInfo;
import org.jdesktop.wonderland.client.tools.AvatarClient.AvatarMessageListener;
import org.jdesktop.wonderland.common.cell.CellID;
import org.jdesktop.wonderland.common.cell.CellSetup;
import org.jdesktop.wonderland.common.cell.CellTransform;
import org.jdesktop.wonderland.common.cell.MultipleParentException;

/**
 *
 * @author  paulby
 */
public class CellBoundsViewer extends javax.swing.JFrame {
    
    private static final Logger logger = Logger.getLogger(CellBoundsViewer.class.getName());
    
    private BoundsTestClientSession session;
    
    private LocalAvatar localAvatar;
    
    private Vector3f location = new Vector3f();
    private static final float STEP = 2f;
    
    /** Creates new form CellBoundsViewer */
    public CellBoundsViewer(String[] args) {
        BoundsPanel boundsPanel;
        initComponents();
        boundsPanel = new BoundsPanel();
        centerPanel.add(boundsPanel, BorderLayout.CENTER);
        
        long userNum = System.currentTimeMillis();
        
        WonderlandServerInfo server = new WonderlandServerInfo("localhost", 1139);
//        LoginParameters loginParams = new LoginParameters("foo"+userNum, "test".toCharArray());
        LoginParameters loginParams = new LoginParameters("test", "test".toCharArray());
        
        // create a session
        session = new BoundsTestClientSession(server, 
                boundsPanel);
        ClientContext.registerCellCache(boundsPanel, session);
        
        localAvatar = session.getLocalAvatar();
                
        try {
            session.login(loginParams);
        } catch (LoginFailureException ex) {
            logger.log(Level.SEVERE, null, ex);
        }
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        centerPanel = new javax.swing.JPanel();
        jPanel1 = new javax.swing.JPanel();
        leftB = new javax.swing.JButton();
        rightB = new javax.swing.JButton();
        forwardB = new javax.swing.JButton();
        backwardB = new javax.swing.JButton();
        jMenuBar1 = new javax.swing.JMenuBar();
        jMenu1 = new javax.swing.JMenu();
        exitMI = new javax.swing.JMenuItem();
        jMenu2 = new javax.swing.JMenu();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setMinimumSize(new java.awt.Dimension(640, 480));

        centerPanel.setLayout(new java.awt.BorderLayout());

        jPanel1.setLayout(new java.awt.GridBagLayout());

        leftB.setText("Left");
        leftB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                leftBActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        jPanel1.add(leftB, gridBagConstraints);

        rightB.setText("Right");
        rightB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                rightBActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.insets = new java.awt.Insets(0, 4, 0, 0);
        jPanel1.add(rightB, gridBagConstraints);

        forwardB.setText("Forward");
        forwardB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                forwardBActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridwidth = 2;
        jPanel1.add(forwardB, gridBagConstraints);

        backwardB.setText("Backward");
        backwardB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                backwardBActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.gridwidth = 2;
        jPanel1.add(backwardB, gridBagConstraints);

        centerPanel.add(jPanel1, java.awt.BorderLayout.PAGE_END);

        getContentPane().add(centerPanel, java.awt.BorderLayout.CENTER);

        jMenu1.setText("File");

        exitMI.setText("Exit");
        exitMI.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exitMIActionPerformed(evt);
            }
        });
        jMenu1.add(exitMI);

        jMenuBar1.add(jMenu1);

        jMenu2.setText("Edit");
        jMenuBar1.add(jMenu2);

        setJMenuBar(jMenuBar1);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void exitMIActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exitMIActionPerformed
        System.exit(0);
    }//GEN-LAST:event_exitMIActionPerformed

    private void leftBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_leftBActionPerformed
        location.x -= STEP;
        localAvatar.localMoveRequest(location, null);
}//GEN-LAST:event_leftBActionPerformed

    private void rightBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_rightBActionPerformed
        location.x += STEP;
        localAvatar.localMoveRequest(location, null);
    }//GEN-LAST:event_rightBActionPerformed

    private void backwardBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_backwardBActionPerformed
        location.z += STEP;
        localAvatar.localMoveRequest(location, null);

    }//GEN-LAST:event_backwardBActionPerformed

    private void forwardBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_forwardBActionPerformed
        location.z -=STEP;
        localAvatar.localMoveRequest(location, null);

    }//GEN-LAST:event_forwardBActionPerformed
    
    
    class BoundsPanel extends JPanel implements CellCacheClient.CellCacheMessageListener, CellCache {
        private Vector3f center = new Vector3f();  // Temporary variable
        private Vector3f extent = new Vector3f();   // Temporary variable
        private float scale = 20f;
        private float panelTranslationX = 0f;
        private float panelTranslationY = 0f;
        
        // BoundsPanel actually wraps the cacheImpl
        private CellCacheBasicImpl cacheImpl = new CellCacheBasicImpl();
        
        private Point mousePress = null;
        
        public BoundsPanel() {
            addMouseMotionListener(new MouseMotionAdapter() {
                @Override
                public void mouseDragged(MouseEvent e) {
                    panelTranslationX = e.getX() - mousePress.x;
                    panelTranslationY = e.getY() - mousePress.y;
                    repaint();
                }
            });
            
            addMouseListener(new MouseAdapter() {
                @Override
               public void mousePressed(MouseEvent e) {
                   mousePress = e.getPoint();
                   mousePress.x -= panelTranslationX;
                   mousePress.y -= panelTranslationY;
               } 
            });
            
            addMouseWheelListener(new MouseWheelListener() {

                public void mouseWheelMoved(MouseWheelEvent e) {
                    int rot = e.getWheelRotation();
                    if (rot>0)
                        scale *= rot*1.2;
                    else
                        scale /= -rot*1.2;
                    repaint();
                }
                
            });
        }
        
        @Override
        public void paint(Graphics gr) {
            Graphics2D g = (Graphics2D)gr;
            g.clearRect(0, 0, getWidth(), getHeight());
            g.translate(panelTranslationX, panelTranslationY);
            
                for(Cell c : cacheImpl.getCells())
                    drawCell(c, g);
        }
        
        private void drawCell(Cell cell, Graphics2D g) {
            drawBounds(cell.getCachedVWBounds(), g);
            
            Vector3f cellPos = cell.getLocalToVWorld().getTranslation(null);
            g.drawString(cell.getName(), cellPos.x*scale, cellPos.z*scale);
        }
        
        private void drawBounds(BoundingVolume bounds, Graphics2D g) {
            if (bounds instanceof BoundingBox) {
                BoundingBox box = (BoundingBox)bounds;
                center = box.getCenter(center);
                extent = box.getExtent(extent);
                
                if (extent.x==Float.POSITIVE_INFINITY)
                    return;
                
                g.drawRect((int)((center.x-extent.x)*scale), 
                           (int)((center.z-extent.z)*scale), 
                           (int)((extent.x*2)*scale), 
                           (int)((extent.z*2)*scale));
            } else if (bounds instanceof BoundingSphere) {
                BoundingSphere sphere = (BoundingSphere)bounds;
                center = sphere.getCenter(center);
                float radius = sphere.getRadius();
                
                if (radius==Float.POSITIVE_INFINITY)
                    return;
                
                g.drawOval((int)((center.x-radius)*scale), 
                           (int)((center.z-radius)*scale), 
                           (int)((radius*2)*scale), 
                           (int)((radius*2)*scale));
            } else {
                System.out.println("Unsupported bounds type "+bounds);
            }
        }

        public void loadCell(CellID cellID, 
                String className, 
                BoundingVolume localBounds, 
                CellID parentCellID, 
                String channelName, 
                CellTransform cellTransform, 
                CellSetup setup) {
            cacheImpl.loadCell(cellID, 
                               className, 
                               localBounds, 
                               parentCellID, 
                               channelName, 
                               cellTransform, 
                               setup);
        }

        public void unloadCell(CellID cellID) {
            cacheImpl.unloadCell(cellID);
            repaint();
        }

        public void deleteCell(CellID cellID) {
            cacheImpl.deleteCell(cellID);
            repaint();
        }

        public void setRootCell(CellID cellID) {
            cacheImpl.setRootCell(cellID);
        }

        /**
         * The cell has moved. If it's an entity cell the transform has already
         * been updated, so just process the cache update. If its not an
         * entity cell then update the transform and cache.
         * 
         * @param cellID
         * @param cellTransform
         */
        public void moveCell(CellID cellID, CellTransform cellTransform) {

            repaint();
        }

        public void loadClientAvatar(CellID cellID, String className, BoundingVolume localBounds, CellID parentCellID, String channelName, CellTransform cellTransform, CellSetup setup) {
            loadCell(cellID, className, localBounds, parentCellID, channelName, cellTransform, setup);
            System.out.println("CellBoundsViewer.loadClientAvatar GOT LOCAL AVATAR "+cellID);
        }

/*************************************************
 * CellCache implementation
 *************************************************/
        public Cell getCell(CellID cellId) {
            return cacheImpl.getCell(cellId);
        }
        
/*************************************************
 * End CellCache implementation
 *************************************************/
    }
    
    /**
     * @param args the command line arguments
     */
    public static void main(final String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new CellBoundsViewer(args).setVisible(true);
            }
        });
    }
    
   
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton backwardB;
    private javax.swing.JPanel centerPanel;
    private javax.swing.JMenuItem exitMI;
    private javax.swing.JButton forwardB;
    private javax.swing.JMenu jMenu1;
    private javax.swing.JMenu jMenu2;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JButton leftB;
    private javax.swing.JButton rightB;
    // End of variables declaration//GEN-END:variables
    
}
